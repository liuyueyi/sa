
KMC SA 1.0.0 28 Aug 2014
 
INSTALLATION
------------
This project used RSA and BASE64 function for Asymmetric encryption, so in order to install this package under a Unix derivative, you need install openssl1.0.1h first. Download install package from website(http://www.openssl.org/), then install openssl.
 
 If you want to just get on with it, do:

  $ make
  $ sudo make install
  
 If you want to uninstall this product, do:
  $ sudo make uninstall


OPENSSL DESCRYPTION
------------------- 
RSA Asymmetric encryption:
 	init rsa: 			RSA_new
 	init rsa from file:	PEM_read_RSAPrivateKey, PEM_read_RSA_PUBKEY
 	set rsa key: 		RSA_general_key, BN_bin2bn
 	verify rsa key: 	RSA_check_key
 	encrypt: 			RSA_public_encrypt, RSA_private_encrypt
	decrypt: 			RSA_private_decrypt, RSA_public_decrypt
 	sign: 				RSA_sign
 	verify: 			RSA_verify
 	free RSA: 			RSA_free

 Decrypt Process:
	rsa = PEM_read_RSA_PUBKEY(public_key_pathname, NULL, NULL, NULL ) 
	int ret = RSA_private_decrypt(int flen, const unsigned char *from, unsigned char *to, RSA *rsa, int padding); // if t >= 0, decrypt succeed
	RSA_free(rsa)
	

BASE64:
	use bio to implements base64
	init BIO:		BIO *b64 = BIO_new(BIO_f_base64());
	no newline:		BIO_set_flags(b64, BIO_FLAGS_BASE64_NO_NL);
	base 64:		BIO_write(b64, char *input, strlen(input));
	flush cache:	BIO_flush(b64);
	get result:		BIO_get_mem_ptr(b64, &bptr); //*bptr is the result
	
Base64 Process:
	 b64 = BIO_new(BIO_f_base64());
     bio = BIO_new_fp(stdout, BIO_NOCLOSE);
     bio = BIO_push(b64, bio);
     BIO_write(bio, char *input, strlen(input));
     BIO_flush(bio);
	 BIO_get_mem_ptr(b64, &bptr);
     BIO_free_all(bio);


REGISTER SM2 ALGORITHM
----------------------
Modify Makefile:
  original:
	OBJS_KM = main.o config.o rsa.o encrypt.o
	
	kmc : $(OBJS_KM)
	$(CC) ${CFLAGS} -o kmc $(OBJS_KM) -lcrypto 

	kmd : $(OBJS_KMD)
	$(CC) ${CFLAGS} -o kmd $(OBJS_KMD) rsa.o encrypt.o -lcrypto

  new:
	OBJS_KM = main.o config.o rsa.o encrypt.o sm2.o
	
	kmc : $(OBJS_KM)
	$(CC) -static ${CFLAGS} -o kmc $(OBJS_KM) -lcrypto -lld -L. -lecc

	kmd : $(OBJS_KMD)
	$(CC) -static ${CFLAGS} -o kmd $(OBJS_KMD) rsa.o encrypt.o sm2.o -lcrypto -lld -L. -lecc

Modify encrypt.c
	function : set_encryption_method()
		after if statement add next code or uncomment the code
		else if (strcmp(method, "sm") == 0 || strcmp(method, "SM") == 0)
		{
			e->encrypt = sm2_encrypt;
			e->decrypt = sm2_decrypt;
			e->sha1 = sm2_sha1;
		}

Modify encrypt.h
	add:
	#include "sm2.h"
 
CONFIG FILE FORMAT
------------------ 
Config file name should be started with encryption method such as "rsa_xxx" or "sm_xxx", the file name tell you which encrypt method to use!
Config file saved all the id, key and uuid information. Each line contained valied id, key and uuid. One id can match many uuid, however one uuid can only match one id. The line start with '#' is Comment lines, you can ignore it.

	--id: the volume key's unique id
	--key: the cipher of Symmetric key	
	--uuid: the volume's unique id
	--sk_pathname: private key pathname
	--pk_pathname: public key pathname
	

SERVER COMMAND
--------------
  you can either use init.sh to start/stop/restart the server, or directly input ./kmd under terminal to start the server.The kmd.pid file saved the process pid of the server, so if you want to kill the server process, except use init.sh script, you can also directly input(kill -9 `cat kmd.pid`) to kill the server
  
  for example:
    start server:  
    	sudo kmd.sh start
    kill server:  
    	sudo kmd.sh kill
    restart server: 
    	sudo kmd.sh restart
	get help:
		sudo kmd.sh help
  
  If you want to print the debug infomation, do:
        sudo kmd -d=[0..2]

        
SERCER PROCESS FLOW
-------------------
  --to connect the server, the client should first send the encrypted method(such as:rsa, sm),then the server will generate a random number which is less than 1000, and encrypt the number by the select encrypted method.
  --server return the cipher to the client, then client should decrypt the cipher by it's private key, after this client return the nunmber to server
  --server verify the receive number, and compare the two number
  --not equal
  		then return 'N', then close the socket
  -- equal
    	start to transport data

Server command:
  --'A': receive the data from kmc, and save it append to the original key file
  --'R': receive the data form kmc, and replace the the original key with the received data
  --'T': send the key file's data to kmc
 
Attention:
  when receive data from kmc or send data to kmc, in order to ensure the data is corrected and integrity, the produce calculate the sha1 digest. So client should send sha1 digest before data and should verify the receive data's sha1 digest 	
